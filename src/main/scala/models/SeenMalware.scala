package models

import com.typesafe.config._
import slick.driver.SQLiteDriver.api._
import scala.concurrent.Future
import scala.concurrent.ExecutionContext.Implicits.global

// Logical object modeling
case class SeenMalware(sha256: String,
                       var disposition: Int,
                       var count: Int) {

   override def toString() = {
     s"""
     |{
     | 'sha256': '$sha256',
     | 'disposition': $disposition,
     | 'count': $count
     |}
     """.stripMargin
   }
}

// Json to object mapper
object SeenMalware {
  import play.api.libs.functional.syntax._
  import play.api.libs.json._

  implicit val seenMalwareReads: Reads[SeenMalware] = (
    (JsPath \ "sha").read[String] and
    (JsPath \ "dp").read[Int] and
    ((JsPath \ "count").read[Int] orElse Reads.pure(1))
  ) (SeenMalware.apply _)
}

// Table representation
class SeenMalwares(tag: Tag) extends Table[SeenMalware](tag, "seen_malware") {
  def sha256 = column[String]("sha", O.PrimaryKey)
  def disposition = column[Int]("dp")
  def count = column[Int]("cnt")

  def * = (sha256, disposition, count) <> (
    (SeenMalware.apply _).tupled,
    SeenMalware.unapply
  )
}

// Data Access Object
object SeenMalwaresDAO extends TableQuery(new SeenMalwares(_)) {
  val typesafeConfig = ConfigFactory.load()
  val dbEndpoint = typesafeConfig.getString("sqlite.url")
  val javaDriver = typesafeConfig.getString("sqlite.driver")

  val db = Database.forURL(dbEndpoint, driver = javaDriver)

  def findBySha(sha256: String): Future[Option[SeenMalware]] = {
    // Select all records of that particular SHA256 and return the first result
    db.run(this.filter(_.sha256 === sha256).result).map(_.headOption)
  }

  def create(malware: SeenMalware): Future[Int] = {
    db.run(this += malware)
  }

  def update(malware: SeenMalware): Future[Int] = {
    db.run(this.filter(_.sha256 === malware.sha256).update(malware))
  }
}
